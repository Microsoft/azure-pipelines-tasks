{
  "loc.friendlyName": "Azure VM 확장 집합 배포",
  "loc.helpMarkDown": "[자세한 정보](https://go.microsoft.com/fwlink/?linkid=852117)",
  "loc.description": "가상 머신 확장 집합 이미지 배포",
  "loc.instanceNameFormat": "Azure VMSS $(vmssName): $(action)",
  "loc.releaseNotes": "- 사용자 지정 가상 머신 이미지로 Azure 가상 머신 확장 집합을 업데이트합니다.",
  "loc.group.displayName.AzureDetails": "Azure 세부 정보",
  "loc.group.displayName.Image": "이미지 세부 정보",
  "loc.group.displayName.StartupConfiguration": "Configure start-up",
  "loc.group.displayName.Advanced": "고급",
  "loc.input.label.ConnectedServiceName": "Azure 구독",
  "loc.input.help.ConnectedServiceName": "확장 집합에 대한 Azure Resource Manager 구독을 선택합니다.",
  "loc.input.label.action": "작업",
  "loc.input.help.action": "Choose between updating a VM scale set by using a VHD image and/or by running deployment/install scripts using Custom Script VM extension.<br/>The VHD image approach is better for scaling quickly and doing rollback. The extension approach is useful for post deployment configuration, software installation, or any other configuration / management task.<br/>You can use a VHD image to update a VM scale set only when it was created by using a custom image, the update will fail if the VM Scale set was created by using a platform/gallery image available in Azure.<br/>The Custom script VM extension approach can be used for VM scale set created by using either custom image or platform/gallery image.",
  "loc.input.label.vmssName": "가상 머신 확장 집합 이름",
  "loc.input.help.vmssName": "Name of VM scale set which you want to update by using either a VHD image or by using Custom script VM extension.",
  "loc.input.label.vmssOsType": "OS type",
  "loc.input.help.vmssOsType": "Select the operating system type of VM scale set.",
  "loc.input.label.imageUrl": "이미지 URL",
  "loc.input.help.imageUrl": "Specify the URL of VHD image. If it is an Azure storage blob url, the storage account location should be same as scale set location.",
  "loc.input.label.customScriptsDirectory": "Custom script directory",
  "loc.input.help.customScriptsDirectory": "Path to directory containing custom script(s) that will be run by using Custom Script VM extension. The extension approach is useful for post deployment configuration, application/software installation, or any other application configuration/management task. For example: the script can set a machine level environment variable which the application uses, like database connection string.",
  "loc.input.label.customScript": "Command",
  "loc.input.help.customScript": "The script that will be run by using Custom Script VM extension. This script can invoke other scripts in the directory. The script will be invoked with arguments passed below.<br/>This script in conjugation with such arguments can be used to execute commands. For example:<br/>1. Update-DatabaseConnectionStrings.ps1 -clusterType dev -user $(dbUser) -password $(dbUserPwd) will update connection string in web.config of web application.<br/>2. install-secrets.sh --key-vault-type prod -key serviceprincipalkey will create an encrypted file containing service principal key.",
  "loc.input.label.customScriptArguments": "Arguments",
  "loc.input.help.customScriptArguments": "The custom script will be invoked with arguments passed. Build/Release variables can be used which makes it easy to use secrets.",
  "loc.input.label.customScriptsStorageAccount": "Azure storage account where custom scripts will be uploaded",
  "loc.input.help.customScriptsStorageAccount": "The Custom Script Extension downloads and executes scripts provided by you on each virtual machines in the VM scale set. These scripts will be stored in the storage account specified here. Specify a pre-existing ARM storage account.",
  "loc.input.label.skipArchivingCustomScripts": "Skip Archiving custom scripts",
  "loc.input.help.skipArchivingCustomScripts": "By default, this task creates a compressed archive of directory containing custom scripts. This improves performance and reliability while uploading to azure storage. If not selected, archiving will not be done and all files will be inidividually uploaded.",
  "loc.messages.InvalidAction": "이 작업은 정의되지 않았습니다. 작업 작성자에게 확인하세요.",
  "loc.messages.TaskNotFound": "Task.json 파일을 찾을 수 없음: %s",
  "loc.messages.TaskConstructorFailed": "초기화하는 동안 작업이 실패했습니다. 오류: %s",
  "loc.messages.InvalidValue": "%s은(는) 유효한 값이 아닙니다. 유효한 값은 %s입니다.",
  "loc.messages.VMSSListFetchFailed": "VMSS 세부 정보를 가져오지 못했습니다. 오류: %s",
  "loc.messages.NoVMSSFound": "이름이 %s인 VMSS를 찾을 수 없습니다.",
  "loc.messages.FailedToGetRGForVMSS": "VMSS %s의 리소스 그룹 정보를 가져오지 못했습니다.",
  "loc.messages.VMSSImageUpdateFailed": "VMSS %s의 이미지를 업데이트하지 못했습니다. 오류: %s",
  "loc.messages.UpdatedVMSSImage": "VMSS 이미지를 업데이트했습니다.",
  "loc.messages.GetVMSSExtensionsListFailed": "VMSS %s의 VM 확장 목록을 가져오지 못했습니다. 오류: %s.",
  "loc.messages.CustomScriptExtensionRemoved": "사용자 지정 스크립트 확장 %s이(가) 제거되었습니다.",
  "loc.messages.CustomScriptExtensionInstalled": "사용자 지정 스크립트 확장 %s이(가) 설치되었습니다.",
  "loc.messages.RemovingCustomScriptExtension": "VMSS에는 이미 사용자 지정 스크립트 확장 %s이(가) 있습니다. 이 확장이 먼저 제거됩니다.",
  "loc.messages.RemoveVMSSExtensionsFailed": "VM 확장 %s을(를) 제거하지 못했습니다. 오류: %s.",
  "loc.messages.SettingVMExtensionFailed": "VMSS에 VM 사용자 지정 스크립트 확장을 설치하지 못했습니다. 오류: %s.",
  "loc.messages.VMSSNameCannotBeNull": "VMSS 이름은 null이거나 정의되지 않은 상태일 수 없으며, 문자열 형식이어야 합니다.",
  "loc.messages.GetVMSSFailed": "리소스 그룹이 %s이고 이름이 %s인 VMSS 세부 정보를 가져오지 못했습니다. 오류: %s",
  "loc.messages.VMSSDoesNotHaveCustomImage": "VMSS %s은(는) 플랫폼 이미지를 사용하고 있으므로 업데이트할 수 없습니다. 현재 사용자 지정 이미지를 사용 중인 VMSS만 업데이트할 수 있습니다.",
  "loc.messages.VMSSImageUrlCannotBeNull": "이미지 URL은 비어 있지 않은 문자열이어야 합니다.",
  "loc.messages.VMSSImageAlreadyUptoDate": "%s의 이미지가 이미 최신 상태입니다. 이미지 업데이트를 건너뜁니다.",
  "loc.messages.NewVMSSImageUrl": "새 VMSS 이미지의 URL: %s.",
  "loc.messages.VMSSUpdateImage": "새 이미지를 사용하도록 VMSS %s을(를) 업데이트하는 중...",
  "loc.messages.ResourceNameCannotBeNull": "리소스 이름은 null일 수 없습니다.",
  "loc.messages.ArchivingCustomScripts": "사용자 지정 스크립트 디렉터리 %s의 압축된 보관 파일을 생성하는 중입니다.",
  "loc.messages.SkippedArchivingCustomScripts": "Skipped archiving custom scripts directory",
  "loc.messages.CustomScriptsArchiveFile": "사용자 지정 스크립트 보관 파일이 %s에 생성되었습니다.",
  "loc.messages.CopiedInvokerScript": "사용자 지정 스크립트 보관 파일의 압축을 풀고 실행할 스크립트가 %s에 복사되었습니다.",
  "loc.messages.CustomScriptsArchivingFailed": "사용자 지정 스크립트를 압축할 수 없습니다. 개별 파일을 사용합니다.",
  "loc.messages.UploadingCustomScriptsBlobs": "%s에서 Azure Blob으로 사용자 지정 스크립트를 업로드하는 중입니다.",
  "loc.messages.UploadingToStorageBlobsFailed": "사용자 지정 스크립트를 Azure Blob Storage로 업로드하지 못했습니다. 오류: %s.",
  "loc.messages.DestinationBlobContainer": "컨테이너 URL %s에 파일이 업로드됩니다.",
  "loc.messages.StorageAccountDoesNotExist": "이름이 %s인 Azure Storage 계정을 가져오지 못했습니다.",
  "loc.messages.activeDirectoryResourceIdUrlCannotBeEmpty": "Active Directory 리소스 URL은 비워 둘 수 없습니다.",
  "loc.messages.StorageAccountCannotBeNull": "storage accountName은 null이거나 정의되지 않은 상태일 수 없으며, 문자열 형식이어야 합니다.",
  "loc.messages.ArtifactItemsTruncationWarning": "Downloaded items may be trucated at 5000 items, all artifact items might not have been downloaded.",
  "loc.messages.CreatedBlobForItem": "Created blob for item %s. Blob uri: %s.",
  "loc.messages.CreatedContainer": "Created container %s.",
  "loc.messages.ErrorInReadStream": "Error in Read stream: %s.",
  "loc.messages.ErrorInWriteStream": "Error in write stream: %s.",
  "loc.messages.FailedToCreateBlob": "Failed to create blob %s. Error: %s.",
  "loc.messages.FailedToCreateContainer": "Failed to create container %s. Error: %s.",
  "loc.messages.FailedToListItemInsideContainer": "Failed to list items inside container: %s. Error: %s.",
  "loc.messages.SuccessFullyFetchedItemList": "Successfully fetcted list of items",
  "loc.messages.UnableToFetchItem": "Unable to fetch item: %s. Error: %s.",
  "loc.messages.UploadingItem": "Uploading %s."
}